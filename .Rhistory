# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 1
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 29
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
# plot survival
plotData = data.frame(pSurvival = kmscResults$kmOnGrid, time = trialTicks[[condName]])
ggplot(plotData, aes(time, pSurvival)) + geom_line() + ylim(c(0, 1)) + displayTheme +
ggtitle(label)
#probability of wait
tau = para[2]
waitProb = exp(vaWaits * tau) / (exp(vaWaits*tau) + exp(vaQuits* tau))
plotData$waitProb = waitProb[,endTick]
# check ws
#
vaWaits = tempt$vaWaits
vaQuits = tempt$vaQuits
wIni = para[5]
gamma = para[3]
nTimeStep = otherPara$tMax / otherPara$stepDuration
for(i in 1 : endTick){
vaQuits[is.na(vaQuits[,i]),i] = vaQuits[match(NA, vaQuits[,i]) -1,i]
}
for(i in 1: endTick){
cIdx = i
plotData = data.frame(va =c(vaWaits[,cIdx], vaQuits[,cIdx]),
time = rep( 1 : (otherPara$tMax / otherPara$stepDuration), 2),
action = rep(c('wait', 'quit'),
each = otherPara$tMax / otherPara$stepDuration))
label = sprintf('last, rwd = %d, tw = %.2f; rwd = %d, tw =%.2f',
tempt$trialEarnings[i-1], waitDuration[i-1],
tempt$trialEarnings[i], waitDuration[i])
if(is.na(tempt$timeWaited[i] )){
int_num = floor(tempt$rewardDelays[i])
endStep =  tempt$rewardDelays[i] + 0.5  + 0.5 * ((tempt$rewardDelays[i] - int_num) > 0.5)
endStep = endStep / stepDuration
}else{
endStep = tempt$timeWaited[i] / stepDuration
}
p = ggplot(plotData, aes(time, va, color = action)) + geom_line() +
geom_vline(xintercept = endStep) +
ggtitle(label) + xlab('step')
# plotData$waitProb = waitProb[,i]
# p = ggplot(plotData[plotData$action == 'wait',], aes(time, waitProb)) + geom_line()+
#   ggtitle(label) + xlim(c(1,3)) + xlab('step')
print(p)
readline(prompt = paste(i, '(hit ENTER to continue)'))
}
cond
#
phi = para[1]
tau = para[2]
gamma = para[3]
lambda = para[4]
wIni = para[5]
# task para
source('taskFxs.R')
source("wtwSettings.R")
load('QStarData/xsLists.RData')
xsList = xsLists[[cond]]
# read otherPara
tMax= otherPara[['tMax']]
stepDuration = otherPara[['stepDuration']]
timeTicks = otherPara[['timeTicks']] # begin timepoint of states
nTimeStep = tMax / stepDuration
# read MSPara
nMS = MSPara$nMS
sigma = MSPara[['sigma']]
MSMus = MSPara[['MSMus']]
traceDecay = MSPara[['traceDecay']]
# define trace values of step t as 0.95^(t - 1)
# we can also define it as 0.95^t, it is abitrary
traceValues = traceDecay ^ ((1 : nTimeStep) - 1)
# actionList
actionList = c('wait', 'quit') # wait means wait until t+1, quit means quit at t
########### simulation repeatedly ############
# initialize action value, eligibility trace and stat
ws = rep(wIni, nMS) # weight vector for "wait"
#ws = rep(0, nMS) # weight vector for "wait"
#ws[1] = wIni # encourage explore at first
es = rep(0, nMS); # es vector for "wait"
onsetXs = xsList[1,]
xs = onsetXs
# additionally initialize vaWaits and vaQuits
vaWaits = matrix(NA, tMax / stepDuration, blockSecs / iti + 1);
vaQuits = matrix(NA, tMax / stepDuration, blockSecs / iti + 1);
endTimes = rep(NA, length = (blockSecs / iti + 1))
# initialize time and reward seq
totalSecs = 0
seq = c()
rewardDelays = rep(0, blockSecs / iti + 1)
tIdx = 0
stepGap = 1 # since es = 0 initially, so this value is abitratry
# initialize outputs
trialEarnings = rep(0, blockSecs / iti + 1)
timeWaited = rep(0, blockSecs / iti + 1)
tIdx = tIdx + 1
# sample rewardDelay
rewardOutputs = drawSample(cond, seq)
rewardDelay = rewardOutputs[['delay']]
seq = rewardOutputs[['seq']]
# calculaye available time steps
# since we use floor there maybe 0.5 sec error (less than 90 s)
nAvaStep = min(floor((blockSecs - totalSecs) / stepDuration), nTimeStep)
t = 1
# calculte action value
vaQuit = onsetXs %*% ws * gamma^(iti / stepDuration) # didn't consider iTi, to stop getting things to complex
vaWait = xs %*% ws;
vaQuits[t, tIdx] = vaQuit;
vaWaits[t, tIdx] = vaWait;
# determine action
waitRate = exp(vaWait * tau) / sum(exp(vaWait* tau)  + exp(vaQuit * tau) )
# used to be exp(vaWait) * tau
# when gamma is large, sometimes vaWait will be very large, sothat waitRate is NA
if(is.na(waitRate)){
waitRate = 1
}
action = ifelse(runif(1) < waitRate, 'wait', 'quit')
# next reward
# determine whether reward occurs in the step t
# the previous code is wrong, since rewards happens on 16s seconds woudldn't be counted
rewardOccur = rewardDelay <= timeTicks[t + 1] && rewardDelay > timeTicks[t]
# if rewarded and wait, 5; otherwise, 0
getReward = (action == 'wait' && rewardOccur);
nextReward = ifelse(getReward, 5, 0)
# dertime next state
# go to the terminate state if at the final step or quit or reward arrives
trialGoOn= (action == 'wait' && !rewardOccur && t < nAvaStep)
if(trialGoOn){
nextXs = dnorm(traceValues[t + 1], MSMus, sigma) * sigma * traceValues[t + 1]
}else{
nextXs  = onsetXs
}
# update eligilibity trace
# here stepGap meatured between At and At-1
if(action == 'wait'){
es =  gamma^stepGap * lambda * es + xs * c(action == "wait")
# update stepGap
stepGap = ifelse(trialGoOn, 1, iti / stepDuration)
# update action value of quit and wait
# here stepGap meatured between At and At+1
delta = nextReward + c(gamma^(stepGap) * max(nextXs %*% ws, vaQuit) -
ifelse(action == 'wait', vaWait, vaQuit))
ws = ws + phi * delta * es
}
# update xs and stepGap
xs = nextXs
# break the trial didn't continue
# return output
if(!trialGoOn){
trialEarnings[tIdx] = ifelse(nextReward == 5, 5, 0);
# if quit, quit at t, if wait, wait until t+1
timeWaited[tIdx] = ifelse(getReward,NA, ifelse(action == "quit", timeTicks[t], timeTicks[t+1]))
rewardDelays[tIdx] = rewardDelay
break
}
vaWait
vaQuit
ws
timeWaited
timeWaited[1]
t = 2
# calculte action value
vaQuit = onsetXs %*% ws * gamma^(iti / stepDuration) # didn't consider iTi, to stop getting things to complex
vaWait = xs %*% ws;
vaQuits[t, tIdx] = vaQuit;
vaWaits[t, tIdx] = vaWait;
# determine action
waitRate = exp(vaWait * tau) / sum(exp(vaWait* tau)  + exp(vaQuit * tau) )
# used to be exp(vaWait) * tau
# when gamma is large, sometimes vaWait will be very large, sothat waitRate is NA
if(is.na(waitRate)){
waitRate = 1
}
action = ifelse(runif(1) < waitRate, 'wait', 'quit')
# next reward
# determine whether reward occurs in the step t
# the previous code is wrong, since rewards happens on 16s seconds woudldn't be counted
rewardOccur = rewardDelay <= timeTicks[t + 1] && rewardDelay > timeTicks[t]
# if rewarded and wait, 5; otherwise, 0
getReward = (action == 'wait' && rewardOccur);
nextReward = ifelse(getReward, 5, 0)
# dertime next state
# go to the terminate state if at the final step or quit or reward arrives
trialGoOn= (action == 'wait' && !rewardOccur && t < nAvaStep)
if(trialGoOn){
nextXs = dnorm(traceValues[t + 1], MSMus, sigma) * sigma * traceValues[t + 1]
}else{
nextXs  = onsetXs
}
# update eligilibity trace
# here stepGap meatured between At and At-1
if(action == 'wait'){
es =  gamma^stepGap * lambda * es + xs * c(action == "wait")
# update stepGap
stepGap = ifelse(trialGoOn, 1, iti / stepDuration)
# update action value of quit and wait
# here stepGap meatured between At and At+1
delta = nextReward + c(gamma^(stepGap) * max(nextXs %*% ws, vaQuit) -
ifelse(action == 'wait', vaWait, vaQuit))
ws = ws + phi * delta * es
}
# update xs and stepGap
xs = nextXs
# break the trial didn't continue
# return output
if(!trialGoOn){
trialEarnings[tIdx] = ifelse(nextReward == 5, 5, 0);
# if quit, quit at t, if wait, wait until t+1
timeWaited[tIdx] = ifelse(getReward,NA, ifelse(action == "quit", timeTicks[t], timeTicks[t+1]))
rewardDelays[tIdx] = rewardDelay
break
}
ws
vaWait
vaQuit
onsetXs %*% ws
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 1
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 29
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
# plot survival
plotData = data.frame(pSurvival = kmscResults$kmOnGrid, time = trialTicks[[condName]])
ggplot(plotData, aes(time, pSurvival)) + geom_line() + ylim(c(0, 1)) + displayTheme +
ggtitle(label)
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 1
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 29
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
para
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 1
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 29
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 100
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 1
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 100
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
library('ggplot2')
library('dplyr')
library('tidyr')
source('helperFxs.R')
source('simulate.R') # QStar model
source('wtwSettings.R') # wtw settings for both HP and LP
# can't change
source('getPara.R') # functions to get MSPara and otherPara from inputs and wtwSettings
# can change for different MS model, and
#### load
load('QStarData/colpData.RData')
################ selec condition ################
# cond input
condIdx = 2
cond = conditions[condIdx];
condName = conditionNames[condIdx]
condColor = conditionColors[condIdx]
sprintf('Condition : %s %s', cond, condName)
trialTick = trialTicks[[condName]]
########### extract raw data #############
combIdx = 100
para = initialSpace[combIdx,]
MSPara = getMSPara(cond, stepDuration, nMS, traceValues, sigma)
otherPara = getOtherPara(cond, stepDuration)
tempt = QStarModel(para, MSPara, otherPara, cond)
# summarise earnings, AUC, wtw
totalEarnings = sum(tempt$trialEarnings)
waitDuration = tempt$timeWaited
rewardDelay = tempt$rewardDelays
quitIdx = (tempt$trialEarnings == 0)
waitDuration[is.na(waitDuration)] = rewardDelay[is.na(waitDuration)]
endTick = match(0,rewardDelay)
waitDuration = waitDuration[1 : (endTick - 1)]
quitIdx = quitIdx[1 : (endTick - 1)]
kmscResults =  kmscSimple(waitDuration, quitIdx, tMax, trialTick)
AUC = kmscResults$auc
label = sprintf('earn: %d, AUC: %.2f',
totalEarnings, AUC)
# plot trialData
blockData = data.frame(trialEarnings = tempt$trialEarnings,
scheduledWait = tempt$rewardDelays,
timeWaited = tempt$timeWaited,
trialNum = 1 : length(tempt$timeWaited)
)
endTick = match(0, tempt$rewardDelays) - 1
blockData = blockData[1:endTick, ]
trialPlots(blockData, label)
rm(list = ls())
rm(list = ls())
